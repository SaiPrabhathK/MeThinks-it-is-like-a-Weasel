digraph "cluster0weasel.py" {
	graph [compound=True fontname="DejaVu Sans Mono" label="weasel.py" pack=False rankdir=TB ranksep=0.02]
	node [fontname="DejaVu Sans Mono"]
	edge [fontname="DejaVu Sans Mono"]
	1 [label="\"\"\"\lAssignment 01:\l\lREAD:\lhttps://en.wikipedia.org/wiki/Weasel_program\lhttp://rationalwiki.org/wiki/Dawkins_weasel\l\lIn the way I've engineerd this program,\lwe'll use a powerful general purpose chainsaw,\lto accomplish the special-purose task of mowing the lawn...\l\lThis program uses:\l* a full population of randomly initialized strings\l* recombination\l* mutation\l* parent selection\l* survivor selection\l* fitness evalution\l* etc.\lWhile all that is overkill for this particular problem,\lit does serve to illustrate the framework we will build onu\l\"\"\"\limport sys\limport string\limport random\lfrom typing import TypedDict\lclass Individual(TypedDict):\l    genome: str\l    fitness: int\lPopulation = list[Individual]\ldef initialize_individual(genome: str, fitness: int) ->Individual:...\ldef initialize_pop(objective: str, pop_size: int) ->Population:...\ldef recombine_pair(parent1: Individual, parent2: Individual) ->Population:...\ldef recombine_group(parents: Population, recombine_rate: float) ->Population:...\ldef mutate_individual(parent: Individual, mutate_rate: float) ->Individual:...\ldef mutate_group(children: Population, mutate_rate: float) ->Population:...\ldef evaluate_individual(objective: str, individual: Individual) ->None:...\ldef evaluate_group(objective: str, individuals: Population) ->None:...\ldef rank_group(individuals: Population) ->None:...\ldef parent_select(individuals: Population, number: int) ->Population:...\ldef survivor_select(individuals: Population, pop_size: int) ->Population:...\ldef evolve(objective: str, pop_size: int) ->Population:..." fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
	135 [label="if __name__ == '__main__':" fillcolor="#FF6752" shape=diamond style="filled,solid"]
	136 [label="import doctest\limport json\ldoctest.testmod()" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
	136 -> 138 [label=calls style=dashed]
	subgraph cluster_136 {
		graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		138 [label="doctest.testmod" color="#E552FF" shape=tab style=filled]
	}
	139 [label="if len(sys.argv) == 3:" fillcolor="#FF6752" shape=diamond style="filled,solid"]
	139 -> 140 [label=calls style=dashed]
	subgraph cluster_139 {
		graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		140 [label=len color="#E552FF" shape=tab style=filled]
	}
	141 [label="obj_name = finput.readlines()\lOBJECTIVE = obj_name[0].strip()\lPOP_SIZE = int(obj_name[1])\lpopulation = evolve(OBJECTIVE, POP_SIZE)\lfoutput.write(json.dumps(population) + '\n')" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
	141 -> 148 [label=calls style=dashed]
	141 -> 149 [label=calls style=dashed]
	141 -> 150 [label=calls style=dashed]
	141 -> 151 [label=calls style=dashed]
	141 -> 152 [label=calls style=dashed]
	141 -> 153 [label=calls style=dashed]
	141 -> 154 [label=calls style=dashed]
	subgraph cluster_141 {
		graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		148 [label=open color="#E552FF" shape=tab style=filled]
		149 [label="finput.readlines" color="#E552FF" shape=tab style=filled]
		150 [label="obj_name.strip" color="#E552FF" shape=tab style=filled]
		151 [label=int color="#E552FF" shape=tab style=filled]
		152 [label=open color="#E552FF" shape=tab style=filled]
		153 [label=evolve color="#E552FF" shape=tab style=filled]
		154 [label="foutput.write" color="#E552FF" shape=tab style=filled]
		155 [label="json.dumps" color="#E552FF" shape=tab style=filled]
		154 -> 155 [color=black]
	}
	"141_input" [label="finput.readlines" fillcolor="#afeeee" shape=parallelogram style="filled,solid"]
	"141_input" -> 141
	139 -> 141 [label="len(sys.argv) == 3" color=green]
	143 [label="OBJECTIVE = input('What string would you like to evolve?\n')\lPOP_SIZE = int(input('How many individuals would you like to evolve?\n'))\lpopulation = evolve(OBJECTIVE, POP_SIZE)" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
	143 -> 144 [label=calls style=dashed]
	143 -> 145 [label=calls style=dashed]
	143 -> 147 [label=calls style=dashed]
	subgraph cluster_143 {
		graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		144 [label=input color="#E552FF" shape=tab style=filled]
		145 [label=int color="#E552FF" shape=tab style=filled]
		146 [label=input color="#E552FF" shape=tab style=filled]
		145 -> 146 [color=black]
		147 [label=evolve color="#E552FF" shape=tab style=filled]
	}
	"143_input" [label=input fillcolor="#afeeee" shape=parallelogram style="filled,solid"]
	"143_input" -> 143
	139 -> 143 [label="(len(sys.argv) != 3)" color=red]
	136 -> 139 [label="" color=black]
	135 -> 136 [label="__name__ == '__main__'" color=green]
	1 -> 135 [label="" color=black]
	subgraph cluster0Individual {
		graph [compound=True fontname="DejaVu Sans Mono" label=Individual pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		3 [label="genome: str\lfitness: int" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
	}
	subgraph cluster0initialize_individual {
		graph [compound=True fontname="DejaVu Sans Mono" label=initialize_individual pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		6 [label="\"\"\"\l    Purpose:        Create one individual\l    Parameters:     genome as string, fitness as integer (higher better)\l    User Input:     no\l    Prints:         no\l    Returns:        One Individual, as a dict[str, int]\l    Modifies:       Nothing\l    Calls:          Basic python only\l    Tests:          ./unit_tests/*\l    Status:         Do this one!\l    Example doctest:\l    >>> initialize_individual(\"EC is fun\", 10)\l    {'genome': 'EC is fun', 'fitness': 10}\l    >>> initialize_individual(\"Fun is EC\", 9)\l    {'genome': 'Fun is EC', 'fitness': 9}\l    \"\"\"" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		7 [label="return Individual({'genome': genome, 'fitness': fitness})" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		6 -> 7 [label="" color=black]
	}
	subgraph cluster0initialize_pop {
		graph [compound=True fontname="DejaVu Sans Mono" label=initialize_pop pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		11 [label="\"\"\"\l    Purpose:        Create population to evolve\l    Parameters:     Goal string, population size as int\l    User Input:     no\l    Prints:         no\l    Returns:        a population, as a list of Individuals\l    Modifies:       Nothing\l    Calls:          random.choice, string.ascii_letters, initialize_individual\l    Tests:          ./unit_tests/*\l    Status:         Do this one!\l    Example doctest:\l    >>> import random\l    >>> random.seed(42)\l    >>> for _ in range(4):\l    ...     initialize_pop(\"EC is easy\", 2)\l    [{'genome': 'OhbVrpoiVg', 'fitness': 0}, {'genome': 'RVIfLBcbfn', 'fitness': 0}]\l    [{'genome': 'oGMbJmTPSI', 'fitness': 0}, {'genome': 'AoCLrZaWZk', 'fitness': 0}]\l    [{'genome': 'SBvrjnWvgf', 'fitness': 0}, {'genome': 'ygwwMqZcUD', 'fitness': 0}]\l    [{'genome': 'IhyfJsONxK', 'fitness': 0}, {'genome': 'mTecQoXsfo', 'fitness': 0}]\l    \"\"\"\lpopulation = []" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		12 [label="for i in range(pop_size):" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		12 -> 13 [label=calls style=dashed]
		subgraph cluster_12 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			13 [label=range color="#E552FF" shape=tab style=filled]
		}
		14 [label="new_genome = ''" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		16 [label="for i in range(len(objective)):" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		16 -> 17 [label=calls style=dashed]
		subgraph cluster_16 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			17 [label=range color="#E552FF" shape=tab style=filled]
			18 [label=len color="#E552FF" shape=tab style=filled]
			17 -> 18 [color=black]
		}
		19 [label="new_genome = new_genome + random.choice(string.ascii_letters + ' ')" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		19 -> 21 [label=calls style=dashed]
		subgraph cluster_19 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			21 [label="random.choice" color="#E552FF" shape=tab style=filled]
		}
		19 -> 16 [label="" color=black]
		16 -> 19 [label="range(len(objective))" color=green]
		20 [label="new_individual = initialize_individual(new_genome, 0)\lpopulation.append(new_individual)" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		20 -> 22 [label=calls style=dashed]
		20 -> 23 [label=calls style=dashed]
		subgraph cluster_20 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			22 [label=initialize_individual color="#E552FF" shape=tab style=filled]
			23 [label="population.append" color="#E552FF" shape=tab style=filled]
		}
		20 -> 12 [label="" color=black]
		16 -> 20 [label="" color=green]
		14 -> 16 [label="" color=black]
		12 -> 14 [label="range(pop_size)" color=green]
		15 [label="return population" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		12 -> 15 [label="" color=green]
		11 -> 12 [label="" color=black]
	}
	subgraph cluster0recombine_pair {
		graph [compound=True fontname="DejaVu Sans Mono" label=recombine_pair pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		27 [label="\"\"\"\l    Purpose:        Recombine two parents to produce two children\l    Parameters:     Two parents as Individuals\l    User Input:     no\l    Prints:         no\l    Returns:        Two Individuals, as a TypedDict[str, int]\l    Modifies:       Nothing\l    Calls:          Basic python, random.choice, initialize_individual\l    Tests:          ./unit_tests/*\l    Status:         Do this one!\l    Example doctest:\l    >>> import random\l    >>> random.seed(42)\l    >>> i1 = initialize_individual(\"EC is great\", 10)\l    >>> i2 = initialize_individual(\"Great is EC\", 10)\l    >>> for _ in range(4):\l    ...     recombine_pair(i1, i2)\l    [{'genome': 'EC is greaC', 'fitness': 0}, {'genome': 'Great is Et', 'fitness': 0}]\l    [{'genome': 'Ereat is EC', 'fitness': 0}, {'genome': 'GC is great', 'fitness': 0}]\l    [{'genome': 'Great is EC', 'fitness': 0}, {'genome': 'EC is great', 'fitness': 0}]\l    [{'genome': 'EC it is EC', 'fitness': 0}, {'genome': 'Greas great', 'fitness': 0}]\l    \"\"\"\lcrossover_point = random.choice(range(len(parent1['genome'])))\loffspring1 = ''\loffspring2 = ''\loffspring1 += parent1['genome'][0:crossover_point]\loffspring2 += parent2['genome'][0:crossover_point]\loffspring1 += parent2['genome'][crossover_point:]\loffspring2 += parent1['genome'][crossover_point:]" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		27 -> 28 [label=calls style=dashed]
		subgraph cluster_27 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			28 [label="random.choice" color="#E552FF" shape=tab style=filled]
			29 [label=range color="#E552FF" shape=tab style=filled]
			28 -> 29 [color=black]
			30 [label=len color="#E552FF" shape=tab style=filled]
			29 -> 30 [color=black]
		}
		31 [label="return list((initialize_individual(offspring1, 0), initialize_individual(\l    offspring2, 0)))" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		27 -> 31 [label="" color=black]
	}
	subgraph cluster0recombine_group {
		graph [compound=True fontname="DejaVu Sans Mono" label=recombine_group pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		35 [label="\"\"\"\l    Purpose:        Recombines a whole group, returns the new population\l    Parameters:     genome as string, fitness as integer (higher better)\l    User Input:     no\l    Prints:         no\l    Returns:        New population of children\l    Modifies:       Nothing\l    Calls:          Basic python, recombine pair\l    Tests:          ./unit_tests/*\l    Status:         Do this one!\l    Example doctest:\l    >>> import random\l    >>> random.seed(42)\l    >>> i1 = initialize_individual(\"EC is great\", 10)\l    >>> i2 = initialize_individual(\"Great is EC\", 10)\l    >>> pop = [i1, i2]\l    >>> for _ in range(4):\l    ...     recombine_group(pop, 0.8)\l    [{'genome': 'Great is EC', 'fitness': 0}, {'genome': 'EC is great', 'fitness': 0}]\l    [{'genome': 'EC at is EC', 'fitness': 0}, {'genome': 'Greis great', 'fitness': 0}]\l    [{'genome': 'Ereat is EC', 'fitness': 0}, {'genome': 'GC is great', 'fitness': 0}]\l    [{'genome': 'EC is gr EC', 'fitness': 0}, {'genome': 'Great iseat', 'fitness': 0}]\l    \"\"\"\lrecombined_population = []" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		36 [label="for i in range(0, len(parents) - 1, 2):" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		36 -> 37 [label=calls style=dashed]
		subgraph cluster_36 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			37 [label=range color="#E552FF" shape=tab style=filled]
			38 [label=len color="#E552FF" shape=tab style=filled]
			37 -> 38 [color=black]
		}
		39 [label="if recombine_rate > random.random():" fillcolor="#FF6752" shape=diamond style="filled,solid"]
		39 -> 41 [label=calls style=dashed]
		subgraph cluster_39 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			41 [label="random.random" color="#E552FF" shape=tab style=filled]
		}
		42 [label="recombined_population.extend(recombine_pair(parents[i], parents[i + 1]))" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		42 -> 47 [label=calls style=dashed]
		subgraph cluster_42 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			47 [label="recombined_population.extend" color="#E552FF" shape=tab style=filled]
			48 [label=recombine_pair color="#E552FF" shape=tab style=filled]
			47 -> 48 [color=black]
		}
		42 -> 36 [label="" color=black]
		39 -> 42 [label="recombine_rate > random.random()" color=green]
		44 [label="recombined_population.append(parents[i])\lrecombined_population.append(parents[i + 1])" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		44 -> 45 [label=calls style=dashed]
		44 -> 46 [label=calls style=dashed]
		subgraph cluster_44 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			45 [label="recombined_population.append" color="#E552FF" shape=tab style=filled]
			46 [label="recombined_population.append" color="#E552FF" shape=tab style=filled]
		}
		44 -> 36 [label="" color=black]
		39 -> 44 [label="(recombine_rate <= random.random())" color=red]
		36 -> 39 [label="range(0, len(parents) - 1, 2)" color=green]
		40 [label="return recombined_population" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		36 -> 40 [label="" color=green]
		35 -> 36 [label="" color=black]
	}
	subgraph cluster0mutate_individual {
		graph [compound=True fontname="DejaVu Sans Mono" label=mutate_individual pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		52 [label="\"\"\"\l    Purpose:        Mutate one individual\l    Parameters:     One parents as Individual, mutation rate as float (0-1)\l    User Input:     no\l    Prints:         no\l    Returns:        One Individual, as a TypedDict[str, int]\l    Modifies:       Nothing\l    Calls:          Basic python, initialize_individual\l    Tests:          ./unit_tests/*\l    Status:         Do this one!\l    Example doctest:\l    >>> import random\l    >>> random.seed(42)\l    >>> ind = initialize_individual(\"EC is fun\", 10)\l    >>> for _ in range(4):\l    ...     mutate_individual(ind, 0.3)\l    {'genome': 'Eriis BfG', 'fitness': 0}\l    {'genome': 'EC is auB', 'fitness': 0}\l    {'genome': 'EW gs cun', 'fitness': 0}\l    {'genome': 'EC is fuo', 'fitness': 0}\l    \"\"\"\lmutated_genome = ''" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		53 [label="for i in parent['genome']:" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		54 [label="if random.random() < mutate_rate:" fillcolor="#FF6752" shape=diamond style="filled,solid"]
		54 -> 56 [label=calls style=dashed]
		subgraph cluster_54 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			56 [label="random.random" color="#E552FF" shape=tab style=filled]
		}
		57 [label="mutated_genome += random.choice(string.ascii_letters + ' ')" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		57 -> 60 [label=calls style=dashed]
		subgraph cluster_57 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			60 [label="random.choice" color="#E552FF" shape=tab style=filled]
		}
		57 -> 53 [label="" color=black]
		54 -> 57 [label="random.random() < mutate_rate" color=green]
		59 [label="mutated_genome += i" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		59 -> 53 [label="" color=black]
		54 -> 59 [label="(random.random() >= mutate_rate)" color=red]
		53 -> 54 [label="parent['genome']" color=green]
		55 [label="return initialize_individual(mutated_genome, 0)" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		53 -> 55 [label="" color=green]
		52 -> 53 [label="" color=black]
	}
	subgraph cluster0mutate_group {
		graph [compound=True fontname="DejaVu Sans Mono" label=mutate_group pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		64 [label="\"\"\"\l    Purpose:        Mutates a whole Population, returns the mutated group\l    Parameters:     Population, mutation rate as float (0-1)\l    User Input:     no\l    Prints:         no\l    Returns:        One Individual, as a TypedDict[str, int]\l    Modifies:       Nothing\l    Calls:          Basic python, mutate_individual\l    Tests:          ./unit_tests/*\l    Status:         Do this one!\l    Example doctest:\l    >>> import random\l    >>> random.seed(42)\l    >>> i1 = initialize_individual(\"EC is great\", 10)\l    >>> i2 = initialize_individual(\"Great is EC\", 10)\l    >>> pop = [i1, i2]\l    >>> for _ in range(4):\l    ...     mutate_group(pop, 0.3)\l    [{'genome': 'Eriis BfGat', 'fitness': 0}, {'genome': 'Greaa BsWEg', 'fitness': 0}]\l    [{'genome': 'ECcis great', 'fitness': 0}, {'genome': 'Groat is Ew', 'fitness': 0}]\l    [{'genome': 'rC OUDgreat', 'fitness': 0}, {'genome': 'GrcatKis EC', 'fitness': 0}]\l    [{'genome': 'Ep is greFd', 'fitness': 0}, {'genome': 'Gkeay iJ UI', 'fitness': 0}]\l    \"\"\"\lmutated_population = []" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		65 [label="for x in children:" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		66 [label="mutated_population.append(mutate_individual(x, mutate_rate))" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		66 -> 68 [label=calls style=dashed]
		subgraph cluster_66 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			68 [label="mutated_population.append" color="#E552FF" shape=tab style=filled]
			69 [label=mutate_individual color="#E552FF" shape=tab style=filled]
			68 -> 69 [color=black]
		}
		66 -> 65 [label="" color=black]
		65 -> 66 [label=children color=green]
		67 [label="return mutated_population" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		65 -> 67 [label="" color=green]
		64 -> 65 [label="" color=black]
	}
	subgraph cluster0evaluate_individual {
		graph [compound=True fontname="DejaVu Sans Mono" label=evaluate_individual pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		73 [label="\"\"\"\l    Purpose:        Computes and modifies the fitness for one individual\l    Parameters:     Objective string, One Individual\l    User Input:     no\l    Prints:         no\l    Returns:        None\l    Modifies:       The individual (mutable object)\l    Calls:          Basic python only\l    Tests:          ./unit_tests/*\l    Status:         Do this one!\l    Example doctest:\l    >>> i1 = initialize_individual(\"This assignment is hard!\", 0)\l    >>> i2 = initialize_individual(\"This assignment is good!\", 0)\l    >>> objective = \"This assignment is easy!\"\l    >>> evaluate_individual(objective=objective, individual=i1)\l    >>> evaluate_individual(objective=objective, individual=i2)\l    >>> i1\l    {'genome': 'This assignment is hard!', 'fitness': 21}\l    >>> i2\l    {'genome': 'This assignment is good!', 'fitness': 20}\l    \"\"\"\lmatching_genes = 0" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		74 [label="for i in range(len(individual['genome'])):" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		74 -> 75 [label=calls style=dashed]
		subgraph cluster_74 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			75 [label=range color="#E552FF" shape=tab style=filled]
			76 [label=len color="#E552FF" shape=tab style=filled]
			75 -> 76 [color=black]
		}
		77 [label="if individual['genome'][i] == objective[i]:" fillcolor="#FF6752" shape=diamond style="filled,solid"]
		79 [label="matching_genes += 1" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		79 -> 74 [label="" color=black]
		77 -> 79 [label="individual['genome'][i] == objective[i]" color=green]
		77 -> 74 [label="(individual['genome'][i] != objective[i])" color=red]
		74 -> 77 [label="range(len(individual['genome']))" color=green]
		78 [label="individual['fitness'] = matching_genes" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		74 -> 78 [label="" color=green]
		73 -> 74 [label="" color=black]
	}
	subgraph cluster0evaluate_group {
		graph [compound=True fontname="DejaVu Sans Mono" label=evaluate_group pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		83 [label="\"\"\"\l    Purpose:        Computes and modifies the fitness for population\l    Parameters:     Objective string, Population\l    User Input:     no\l    Prints:         no\l    Returns:        None\l    Modifies:       The Individuals, all mutable objects\l    Calls:          Basic python, evaluate_individual\l    Tests:          ./unit_tests/*\l    Status:         Do this one!\l    Example doctest:\l    >>> import random\l    >>> random.seed(42)\l    >>> i1 = initialize_individual(\"This assignment is work!\", 0)\l    >>> i2 = initialize_individual(\"This assignment is hard!\", 0)\l    >>> objective = \"This assignment is easy!\"\l    >>> pop = [i1, i2]\l    >>> evaluate_group(objective=objective, individuals=pop)\l    >>> pop[0]\l    {'genome': 'This assignment is work!', 'fitness': 20}\l    >>> pop[1]\l    {'genome': 'This assignment is hard!', 'fitness': 21}\l    \"\"\"" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		84 [label="for x in individuals:" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		85 [label="evaluate_individual(objective, x)" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		85 -> 87 [label=calls style=dashed]
		subgraph cluster_85 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			87 [label=evaluate_individual color="#E552FF" shape=tab style=filled]
		}
		85 -> 84 [label="" color=black]
		84 -> 85 [label=individuals color=green]
		83 -> 84 [label="" color=black]
	}
	subgraph cluster0rank_group {
		graph [compound=True fontname="DejaVu Sans Mono" label=rank_group pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		90 [label="\"\"\"\l    Purpose:        Create one individual\l    Parameters:     Population of Individuals\l    User Input:     no\l    Prints:         no\l    Returns:        None\l    Modifies:       The population's order (a mutable object)\l    Calls:          Basic python only\l    Tests:          ./unit_tests/*\l    Status:         Do this one!\l    Example doctest:\l    >>> import random\l    >>> random.seed(42)\l    >>> i1 = initialize_individual(\"Zhis glass it isabeesting!\", 2)\l    >>> i2 = initialize_individual(\"This class is motivating!!\", 6)\l    >>> objective = \"This class is captivating!\"\l    >>> pop = [i1, i2]\l    >>> rank_group(pop)\l    >>> pop\l    [{'genome': 'This class is motivating!!', 'fitness': 6}, {'genome': 'Zhis glass it isabeesting!', 'fitness': 2}]\l    \"\"\"\lranked_individuals = []\lranked_individuals = sorted(individuals, key=lambda individual: individual[\l    'fitness'], reverse=True)" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		90 -> 91 [label=calls style=dashed]
		subgraph cluster_90 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			91 [label=sorted color="#E552FF" shape=tab style=filled]
		}
		92 [label="for x in range(len(ranked_individuals)):" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		92 -> 93 [label=calls style=dashed]
		subgraph cluster_92 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			93 [label=range color="#E552FF" shape=tab style=filled]
			94 [label=len color="#E552FF" shape=tab style=filled]
			93 -> 94 [color=black]
		}
		95 [label="individuals[x] = ranked_individuals[x]" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		95 -> 92 [label="" color=black]
		92 -> 95 [label="range(len(ranked_individuals))" color=green]
		90 -> 92 [label="" color=black]
	}
	subgraph cluster0parent_select {
		graph [compound=True fontname="DejaVu Sans Mono" label=parent_select pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		99 [label="\"\"\"\l    Purpose:        Choose parents in direct probability to their fitness\l    Parameters:     Population, the number of individuals to pick.\l    User Input:     no\l    Prints:         no\l    Returns:        Sub-population\l    Modifies:       Nothing\l    Calls:          Basic python, random.choices (hint)\l    Tests:          ./unit_tests/*\l    Status:         Do this one!\l    Example doctest:\l    >>> import random\l    >>> random.seed(42)\l    >>> i1 = initialize_individual(\"gene\", 5)\l    >>> i2 = initialize_individual(\"meme\", 6)\l    >>> i3 = initialize_individual(\"heme\", 4)\l    >>> pop = [i1, i2, i3]\l    >>> for _ in range(4):\l    ...     parent_select(pop, 2)\l    [{'genome': 'meme', 'fitness': 6}, {'genome': 'gene', 'fitness': 5}]\l    [{'genome': 'gene', 'fitness': 5}, {'genome': 'gene', 'fitness': 5}]\l    [{'genome': 'heme', 'fitness': 4}, {'genome': 'meme', 'fitness': 6}]\l    [{'genome': 'heme', 'fitness': 4}, {'genome': 'gene', 'fitness': 5}]\l    \"\"\"\lfitness_list = []" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		100 [label="for x in individuals:" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		101 [label="fitness_list.append(x['fitness'])" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		101 -> 103 [label=calls style=dashed]
		subgraph cluster_101 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			103 [label="fitness_list.append" color="#E552FF" shape=tab style=filled]
		}
		101 -> 100 [label="" color=black]
		100 -> 101 [label=individuals color=green]
		102 [label="selected_parents = random.choices(individuals, weights=fitness_list, k=number)" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		102 -> 104 [label=calls style=dashed]
		subgraph cluster_102 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			104 [label="random.choices" color="#E552FF" shape=tab style=filled]
		}
		105 [label="return selected_parents" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		102 -> 105 [label="" color=black]
		100 -> 102 [label="" color=green]
		99 -> 100 [label="" color=black]
	}
	subgraph cluster0survivor_select {
		graph [compound=True fontname="DejaVu Sans Mono" label=survivor_select pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		109 [label="\"\"\"\l    Purpose:        Picks who gets to live!\l    Parameters:     Population, and population size to return.\l    User Input:     no\l    Prints:         no\l    Returns:        Population, of pop_size\l    Modifies:       Nothing\l    Calls:          Basic python only\l    Tests:          ./unit_tests/*\l    Status:         Do this one!\l    Example doctest:\l    >>> import random\l    >>> random.seed(42)\l    >>> i1 = initialize_individual(\"meme\", 6)\l    >>> i2 = initialize_individual(\"gene\", 5)\l    >>> i3 = initialize_individual(\"heme\", 4)\l    >>> pop = [i1, i2, i3]\l    >>> for _ in range(4):\l    ...     survivor_select(pop, 2)\l    [{'genome': 'meme', 'fitness': 6}, {'genome': 'gene', 'fitness': 5}]\l    [{'genome': 'meme', 'fitness': 6}, {'genome': 'gene', 'fitness': 5}]\l    [{'genome': 'meme', 'fitness': 6}, {'genome': 'gene', 'fitness': 5}]\l    [{'genome': 'meme', 'fitness': 6}, {'genome': 'gene', 'fitness': 5}]\l    \"\"\"" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		110 [label="return individuals[:pop_size]" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		109 -> 110 [label="" color=black]
	}
	subgraph cluster0evolve {
		graph [compound=True fontname="DejaVu Sans Mono" label=evolve pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		115 [label="\"\"\"\l    Purpose:        A whole EC run, main driver\l    Parameters:     The evolved population of solutions\l    User Input:     No\l    Prints:         Updates every time fitness switches.\l    Returns:        Population\l    Modifies:       Various data structures\l    Calls:          Basic python only, all your functions\l    Tests:          ./stdio_tests/* and ./arg_tests/\l    Status:         Giving you this one.\l    \"\"\"\lpopulation = initialize_pop(objective=objective, pop_size=pop_size)\levaluate_group(objective=objective, individuals=population)\lrank_group(individuals=population)\lbest_fitness = population[0]['fitness']\lperfect_fitness = len(objective)\lcounter = 0" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		115 -> 116 [label=calls style=dashed]
		115 -> 117 [label=calls style=dashed]
		115 -> 118 [label=calls style=dashed]
		115 -> 119 [label=calls style=dashed]
		subgraph cluster_115 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			116 [label=initialize_pop color="#E552FF" shape=tab style=filled]
			117 [label=evaluate_group color="#E552FF" shape=tab style=filled]
			118 [label=rank_group color="#E552FF" shape=tab style=filled]
			119 [label=len color="#E552FF" shape=tab style=filled]
		}
		120 [label="while best_fitness < perfect_fitness:" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		121 [label="counter += 1\lparents = parent_select(individuals=population, number=80)\lchildren = recombine_group(parents=parents, recombine_rate=0.8)\lmutate_rate = (1 - best_fitness / perfect_fitness) / 5\lmutants = mutate_group(children=children, mutate_rate=mutate_rate)\levaluate_group(objective=objective, individuals=mutants)\leveryone = population + mutants\lrank_group(individuals=everyone)\lpopulation = survivor_select(individuals=everyone, pop_size=pop_size)" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		121 -> 123 [label=calls style=dashed]
		121 -> 124 [label=calls style=dashed]
		121 -> 125 [label=calls style=dashed]
		121 -> 126 [label=calls style=dashed]
		121 -> 127 [label=calls style=dashed]
		121 -> 128 [label=calls style=dashed]
		subgraph cluster_121 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			123 [label=parent_select color="#E552FF" shape=tab style=filled]
			124 [label=recombine_group color="#E552FF" shape=tab style=filled]
			125 [label=mutate_group color="#E552FF" shape=tab style=filled]
			126 [label=evaluate_group color="#E552FF" shape=tab style=filled]
			127 [label=rank_group color="#E552FF" shape=tab style=filled]
			128 [label=survivor_select color="#E552FF" shape=tab style=filled]
		}
		129 [label="if best_fitness != population[0]['fitness']:" fillcolor="#FF6752" shape=diamond style="filled,solid"]
		130 [label="best_fitness = population[0]['fitness']\lprint('Iteration number', counter, 'with best individual', population[0])" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		130 -> 132 [label=calls style=dashed]
		subgraph cluster_130 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			132 [label=print color="#E552FF" shape=tab style=filled]
		}
		130 -> 120 [label="" color=black]
		129 -> 130 [label="best_fitness != population[0]['fitness']" color=green]
		129 -> 120 [label="(best_fitness == population[0]['fitness'])" color=red]
		121 -> 129 [label="" color=black]
		120 -> 121 [label="best_fitness < perfect_fitness" color=green]
		122 [label="return population" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		120 -> 122 [label="(best_fitness >= perfect_fitness)" color=red]
		115 -> 120 [label="" color=black]
	}
	subgraph cluster_KEY {
		graph [fontname="DejaVu Sans Mono" label=KEY]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		input [fillcolor="#afeeee" shape=parallelogram style=filled]
		default [fillcolor="#FFFB81" shape=rectangle style=filled]
		if [fillcolor="#FF6752" shape=diamond style=filled]
		for [fillcolor="#FFBE52" shape=hexagon style=filled]
		while [fillcolor="#FFBE52" shape=hexagon style=filled]
		call [fillcolor="#E552FF" shape=tab style=filled]
		return [fillcolor="#98fb98" shape=parallelogram style=filled]
		try [fillcolor=orange shape=Mdiamond style=filled]
		raise [fillcolor="#98fb98" shape=house style=filled]
		if -> input [style=invis]
		input -> call [style=invis]
		for -> return [style=invis]
		return -> default [style=invis]
		try -> raise [style=invis]
	}
}
